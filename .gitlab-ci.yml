include:
  - local: 'ci/scripts/build-image/build_cicd_image.yml'
  - local: 'ci/scripts/lint/lint.yml'
  - local: 'ci/scripts/validate/validate_kubernetes.yml'
  - local: 'ci/scripts/validate/validate_terraform.yml'
  - local: 'ci/scripts/plan/plan_dev.yml'
  - local: 'ci/scripts/plan/plan_prod.yml'
  - local: 'ci/scripts/build/build.yml'
  - local: 'ci/scripts/deploy/deploy_terraform_dev.yml'
  - local: 'ci/scripts/deploy/deploy_terraform_prod.yml'
  - local: 'ci/scripts/deploy/deploy_kubernetes_dev.yml'
  - local: 'ci/scripts/deploy/deploy_kubernetes_prod.yml'
  - local: 'ci/scripts/verify/verify_prod.yml'
  - local: 'ci/scripts/monitoring/monitoring.yml'
  - local: 'ci/scripts/verify/verify_dev.yml'
  - local: 'ci/scripts/qa/qa_dev.yml'
  - local: 'ci/scripts/qa/qa_prod.yml'
  - local: 'ci/scripts/cleanup/cleanup_dev.yml'
  - local: 'ci/scripts/cleanup/cleanup_prod.yml'

stages:
  - build-image
  - lint
  - validate
  - plan
  - build
  - deploy
  - backup
  - monitoring
  - verify
  - qa
  - cleanup

variables:
  SSH_KEY_NAME: "ds_exam_key"
  KUBERNETES_DIR: "kubernetes"
  REMOTE_DIR: "wordpress"
  WORDPRESS_PORT: "30080"  # NodePort for ingress
  DEPLOYMENT_TIMEOUT: "300"
  MONITORING_DIR: "monitoring"
  DOCKER_IMAGE: "${CI_REGISTRY_IMAGE}/cicd-tools:latest"
  S3_BUCKET_DATA: "ds-exam-app-data-xotjx8lp"
  S3_BUCKET_CODE: "ds-exam-code-storage-253ysdli"

# Environment-specific variables
.dev_environment: &dev_environment
  variables:
    ENVIRONMENT: "dev"
    TF_VAR_FILE: "environment/dev-terraform.tfvars"
    REPLICA_COUNT: "2"
    MEMORY_REQUEST: "256Mi"
    MEMORY_LIMIT: "512Mi"
    CPU_REQUEST: "200m"
    CPU_LIMIT: "500m"
    CERT_ISSUER: "staging"
  rules:
    - if: $CI_COMMIT_BRANCH == "dev"

# Production Environment
.prod_environment: &prod_environment
  variables:
    ENVIRONMENT: "prod"
    TF_VAR_FILE: "environment/prod-terraform.tfvars"
    REPLICA_COUNT: "3"
    MEMORY_REQUEST: "512Mi"
    MEMORY_LIMIT: "1Gi"
    CPU_REQUEST: "500m"
    CPU_LIMIT: "1000m"
    CERT_ISSUER: "prod"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

build:cicd-image:
  stage: build-image
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_DRIVER: overlay2
  #include: 'ci/scripts/build-image/build_cicd_image.yml'
  extends: .build_cicd_image_script_template
  rules:
    - changes:
        - Dockerfile.cicd
    - if: $CI_COMMIT_BRANCH == "dev" && $CI_PIPELINE_SOURCE == "push" # $CI_COMMIT_BRANCH == "main"
#      when: manual

lint:
  stage: lint
  image: $DOCKER_IMAGE
  #include: 'ci/scripts/lint/lint.yml'
  extends: .lint_script_template
  rules:
    #- if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "dev_chris"
    #- if: $CI_COMMIT_BRANCH == "monitoring"
      allow_failure: true

validate:kubernetes:
  stage: validate
  image: $DOCKER_IMAGE
  #include: 'ci/scripts/validate/validate_kubernetes.yml'
  extends: .validate_script_kubernetes
  rules:
    # - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "dev_chris"
    # - if: $CI_COMMIT_BRANCH == "monitoring"

validate:terraform:
  stage: validate
  image: $DOCKER_IMAGE
  #include: 'ci/scripts/validate/validate_terraform.yml'
  extends: .validate_script_terraform
  rules:
  #  - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "dev_chris"
  #  - if: $CI_COMMIT_BRANCH == "monitoring"

# Terraform Plan_switcher - Dev
plan_switcher:dev:
  stage: plan
  image: $DOCKER_IMAGE
  <<: *dev_environment
  #include: 'ci/scripts/plan/plan_dev.yml'
  extends: .plan_script_dev
  artifacts:
    paths:
      - terraform/tfplan
    expire_in: 1 day

# Terraform Plan_switcher - Prod
plan_switcher:prod:
  stage: plan
  image: $DOCKER_IMAGE
  <<: *prod_environment
  #include: 'ci/scripts/plan/plan_prod.yml'
  extends: .plan_script_prod
  artifacts:
    paths:
      - terraform/tfplan
    expire_in: 1 day

build:
  stage: build
  image: $DOCKER_IMAGE
  #include: 'ci/scripts/build/build.yml'
  extends: .build_script
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "dev_chris"
  #  - if: $CI_COMMIT_BRANCH == "monitoring"
  artifacts:
    paths:
      - $KUBERNETES_DIR/
    expire_in: 1 week

deploy:terraform:dev:
  stage: deploy
  image: $DOCKER_IMAGE
  <<: *dev_environment
  #include: 'ci/scripts/deploy/deploy_terraform_dev.yml'
  extends: .deploy_terraform_dev_template
  artifacts:
    reports:
      dotenv: terraform/terraform.env
    paths:
      - terraform/terraform.env
    expire_in: 1 day

deploy:terraform:prod:
  stage: deploy
  image: $DOCKER_IMAGE
  <<: *prod_environment
  #include: 'ci/scripts/deploy/deploy_terraform_prod.yml'
  extends: .deploy_terraform_prod_template
  artifacts:
    reports:
      dotenv: terraform/terraform.env
    paths:
      - terraform/terraform.env
    expire_in: 1 day
  when: manual

deploy:kubernetes:dev:
  stage: deploy
  image: $DOCKER_IMAGE
  <<: *dev_environment
  needs:
    - deploy:terraform:dev
    - build
  #include: 'ci/scripts/deploy/deploy_kubernetes_prod.yml'
  extends: .deploy_kubernenets_dev_template
  environment:
    name: $ENVIRONMENT
    url: http://$MASTER_IP.nip.io
  artifacts:
    paths:
      - $KUBERNETES_DIR/
    expire_in: 1 week

deploy:kubernetes:prod:
  stage: deploy
  image: $DOCKER_IMAGE
  <<: *prod_environment
  needs:
    - deploy:terraform:prod
    - build
  #include: 'ci/scripts/deploy/deploy_kubernetes_prod.yml'
  extends: .deploy_kubernenets_prod_template
  environment:
    name: $ENVIRONMENT
    url: http://$MASTER_IP.nip.io
  artifacts:
    paths:
      - $KUBERNETES_DIR/
    expire_in: 1 week

# Backup Database and Files - Dev
backup:dev:
  stage: backup
  image: $DOCKER_IMAGE
  <<: *dev_environment
  needs:
    - deploy:kubernetes:dev
  before_script:
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "Starting backups for ${ENVIRONMENT} environment at $(date)"
  script:
    - echo "Backing up MySQL database..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
        # Ensure backup directory exists
        mkdir -p ~/backups
        
        # Get MySQL pod name
        MYSQL_POD=\$(sudo kubectl get pod -l tier=mysql -n wordpress-${ENVIRONMENT} -o jsonpath=\"{.items[0].metadata.name}\")
        echo \"Using MySQL pod: \$MYSQL_POD\"
        
        # Get MySQL password from secret
        MYSQL_PASSWORD=\$(sudo kubectl get secret mysql-pass -n wordpress-${ENVIRONMENT} -o jsonpath=\"{.data.password}\" | base64 --decode)
        
        # Create database backup
        BACKUP_FILE=\"wordpress-db-${ENVIRONMENT}-\$(date +%Y%m%d-%H%M%S).sql.gz\"
        echo \"Creating database backup: \$BACKUP_FILE\"
        sudo kubectl exec \$MYSQL_POD -n wordpress-${ENVIRONMENT} -- bash -c \"mysqldump -u wordpress -p\$MYSQL_PASSWORD wordpress | gzip > /tmp/\$BACKUP_FILE\"
        
        # Copy backup from pod
        sudo kubectl cp wordpress-${ENVIRONMENT}/\$MYSQL_POD:/tmp/\$BACKUP_FILE ~/backups/\$BACKUP_FILE
        
        # Upload backup to S3
        export AWS_ACCESS_KEY_ID=\"$AWS_ACCESS_KEY_ID\"
        export AWS_SECRET_ACCESS_KEY=\"$AWS_SECRET_ACCESS_KEY\"
        aws s3 cp ~/backups/\$BACKUP_FILE s3://${S3_BUCKET_DATA}/backups/databases/\$BACKUP_FILE
        
        echo \"Database backup uploaded to S3: s3://${S3_BUCKET_DATA}/backups/databases/\$BACKUP_FILE\"
      '"
    
    - echo "Backing up WordPress files..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
        # Get WordPress pod name
        WP_POD=\$(sudo kubectl get pod -l app=wordpress,environment=${ENVIRONMENT} -n wordpress-${ENVIRONMENT} -o jsonpath=\"{.items[0].metadata.name}\")
        echo \"Using WordPress pod: \$WP_POD\"
        
        # Create WordPress files backup
        BACKUP_FILE=\"wordpress-files-${ENVIRONMENT}-\$(date +%Y%m%d-%H%M%S).tar.gz\"
        echo \"Creating files backup: \$BACKUP_FILE\"
        
        # Create backup inside pod
        sudo kubectl exec \$WP_POD -n wordpress-${ENVIRONMENT} -- bash -c \"cd /var/www/html && tar -czf /tmp/\$BACKUP_FILE wp-content\"
        
        # Copy backup from pod
        sudo kubectl cp wordpress-${ENVIRONMENT}/\$WP_POD:/tmp/\$BACKUP_FILE ~/backups/\$BACKUP_FILE
        
        # Upload backup to S3
        export AWS_ACCESS_KEY_ID=\"$AWS_ACCESS_KEY_ID\"
        export AWS_SECRET_ACCESS_KEY=\"$AWS_SECRET_ACCESS_KEY\"
        aws s3 cp ~/backups/\$BACKUP_FILE s3://${S3_BUCKET_DATA}/backups/files/\$BACKUP_FILE
        
        echo \"Files backup uploaded to S3: s3://${S3_BUCKET_DATA}/backups/files/\$BACKUP_FILE\"
        
        # Backup Terraform state
        ./backup-terraform-state.sh
      '"
    
    - echo "Running backup verification..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
        export AWS_ACCESS_KEY_ID=\"$AWS_ACCESS_KEY_ID\"
        export AWS_SECRET_ACCESS_KEY=\"$AWS_SECRET_ACCESS_KEY\"
        
        echo \"Verifying database backups...\"
        DB_BACKUPS=\$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/databases/ --recursive | grep wordpress-db-${ENVIRONMENT} | sort | tail -n 5)
        if [ -z \"\$DB_BACKUPS\" ]; then
          echo \"❌ No database backups found!\"
          exit 1
        else
          echo \"✅ Recent database backups:\"
          echo \"\$DB_BACKUPS\"
        fi
        
        echo \"Verifying file backups...\"
        FILE_BACKUPS=\$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/files/ --recursive | grep wordpress-files-${ENVIRONMENT} | sort | tail -n 5)
        if [ -z \"\$FILE_BACKUPS\" ]; then
          echo \"❌ No file backups found!\"
          exit 1
        else
          echo \"✅ Recent file backups:\"
          echo \"\$FILE_BACKUPS\"
        fi
        
        # Check backup freshness
        LATEST_DB_BACKUP=\$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/databases/ --recursive | grep wordpress-db-${ENVIRONMENT} | sort | tail -n 1)
        BACKUP_DATE=\$(echo \$LATEST_DB_BACKUP | awk \"{print \\\$1, \\\$2}\")
        CURRENT_DATE=\$(date -u +\"%Y-%m-%d %H:%M:%S\")
        echo \"Latest backup date: \$BACKUP_DATE\"
        echo \"Current date: \$CURRENT_DATE\"
        
        # Print backup status report
        echo \"======================================\"
        echo \"Backup Status Report - ${ENVIRONMENT}\"
        echo \"======================================\"
        echo \"Total Database Backups: \$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/databases/ --recursive | grep wordpress-db-${ENVIRONMENT} | wc -l)\"
        echo \"Total File Backups: \$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/files/ --recursive | grep wordpress-files-${ENVIRONMENT} | wc -l)\"
        echo \"Latest Database Backup: \$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/databases/ --recursive | grep wordpress-db-${ENVIRONMENT} | sort | tail -n 1)\"
        echo \"Latest File Backup: \$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/files/ --recursive | grep wordpress-files-${ENVIRONMENT} | sort | tail -n 1)\"
        echo \"======================================\"
      '"
    
    - echo "Backup and verification for ${ENVIRONMENT} environment completed at $(date)!"
  environment:
    name: $ENVIRONMENT-backup
    url: http://$MASTER_IP.nip.io
  rules:
    - if: $CI_COMMIT_BRANCH == "dev"
  allow_failure: true

# Backup Database and Files - Production
backup:prod:
  stage: backup
  image: $DOCKER_IMAGE
  <<: *prod_environment
  needs:
    - deploy:kubernetes:prod
  before_script:
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "Starting backups for ${ENVIRONMENT} environment at $(date)"
  script:
    - echo "Backing up MySQL database..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
        # Ensure backup directory exists
        mkdir -p ~/backups
        
        # Get MySQL pod name
        MYSQL_POD=\$(sudo kubectl get pod -l tier=mysql -n wordpress-${ENVIRONMENT} -o jsonpath=\"{.items[0].metadata.name}\")
        echo \"Using MySQL pod: \$MYSQL_POD\"
        
        # Get MySQL password from secret
        MYSQL_PASSWORD=\$(sudo kubectl get secret mysql-pass -n wordpress-${ENVIRONMENT} -o jsonpath=\"{.data.password}\" | base64 --decode)
        
        # Create database backup
        BACKUP_FILE=\"wordpress-db-${ENVIRONMENT}-\$(date +%Y%m%d-%H%M%S).sql.gz\"
        echo \"Creating database backup: \$BACKUP_FILE\"
        sudo kubectl exec \$MYSQL_POD -n wordpress-${ENVIRONMENT} -- bash -c \"mysqldump -u wordpress -p\$MYSQL_PASSWORD wordpress | gzip > /tmp/\$BACKUP_FILE\"
        
        # Copy backup from pod
        sudo kubectl cp wordpress-${ENVIRONMENT}/\$MYSQL_POD:/tmp/\$BACKUP_FILE ~/backups/\$BACKUP_FILE
        
        # Upload backup to S3
        export AWS_ACCESS_KEY_ID=\"$AWS_ACCESS_KEY_ID\"
        export AWS_SECRET_ACCESS_KEY=\"$AWS_SECRET_ACCESS_KEY\"
        aws s3 cp ~/backups/\$BACKUP_FILE s3://${S3_BUCKET_DATA}/backups/databases/\$BACKUP_FILE
        
        echo \"Database backup uploaded to S3: s3://${S3_BUCKET_DATA}/backups/databases/\$BACKUP_FILE\"
      '"
    
    - echo "Backing up WordPress files..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
        # Get WordPress pod name
        WP_POD=\$(sudo kubectl get pod -l app=wordpress,environment=${ENVIRONMENT} -n wordpress-${ENVIRONMENT} -o jsonpath=\"{.items[0].metadata.name}\")
        echo \"Using WordPress pod: \$WP_POD\"
        
        # Create WordPress files backup
        BACKUP_FILE=\"wordpress-files-${ENVIRONMENT}-\$(date +%Y%m%d-%H%M%S).tar.gz\"
        echo \"Creating files backup: \$BACKUP_FILE\"
        
        # Create backup inside pod
        sudo kubectl exec \$WP_POD -n wordpress-${ENVIRONMENT} -- bash -c \"cd /var/www/html && tar -czf /tmp/\$BACKUP_FILE wp-content\"
        
        # Copy backup from pod
        sudo kubectl cp wordpress-${ENVIRONMENT}/\$WP_POD:/tmp/\$BACKUP_FILE ~/backups/\$BACKUP_FILE
        
        # Upload backup to S3
        export AWS_ACCESS_KEY_ID=\"$AWS_ACCESS_KEY_ID\"
        export AWS_SECRET_ACCESS_KEY=\"$AWS_SECRET_ACCESS_KEY\"
        aws s3 cp ~/backups/\$BACKUP_FILE s3://${S3_BUCKET_DATA}/backups/files/\$BACKUP_FILE
        
        echo \"Files backup uploaded to S3: s3://${S3_BUCKET_DATA}/backups/files/\$BACKUP_FILE\"
        
        # Backup Terraform state
        ./backup-terraform-state.sh
      '"
    
    - echo "Running backup verification..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
        export AWS_ACCESS_KEY_ID=\"$AWS_ACCESS_KEY_ID\"
        export AWS_SECRET_ACCESS_KEY=\"$AWS_SECRET_ACCESS_KEY\"
        
        echo \"Verifying database backups...\"
        DB_BACKUPS=\$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/databases/ --recursive | grep wordpress-db-${ENVIRONMENT} | sort | tail -n 5)
        if [ -z \"\$DB_BACKUPS\" ]; then
          echo \"❌ No database backups found!\"
          exit 1
        else
          echo \"✅ Recent database backups:\"
          echo \"\$DB_BACKUPS\"
        fi
        
        echo \"Verifying file backups...\"
        FILE_BACKUPS=\$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/files/ --recursive | grep wordpress-files-${ENVIRONMENT} | sort | tail -n 5)
        if [ -z \"\$FILE_BACKUPS\" ]; then
          echo \"❌ No file backups found!\"
          exit 1
        else
          echo \"✅ Recent file backups:\"
          echo \"\$FILE_BACKUPS\"
        fi
        
        # Check backup freshness
        LATEST_DB_BACKUP=\$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/databases/ --recursive | grep wordpress-db-${ENVIRONMENT} | sort | tail -n 1)
        BACKUP_DATE=\$(echo \$LATEST_DB_BACKUP | awk \"{print \\\$1, \\\$2}\")
        CURRENT_DATE=\$(date -u +\"%Y-%m-%d %H:%M:%S\")
        echo \"Latest backup date: \$BACKUP_DATE\"
        echo \"Current date: \$CURRENT_DATE\"
        
        # Print backup status report
        echo \"======================================\"
        echo \"Backup Status Report - ${ENVIRONMENT}\"
        echo \"======================================\"
        echo \"Total Database Backups: \$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/databases/ --recursive | grep wordpress-db-${ENVIRONMENT} | wc -l)\"
        echo \"Total File Backups: \$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/files/ --recursive | grep wordpress-files-${ENVIRONMENT} | wc -l)\"
        echo \"Latest Database Backup: \$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/databases/ --recursive | grep wordpress-db-${ENVIRONMENT} | sort | tail -n 1)\"
        echo \"Latest File Backup: \$(aws s3 ls s3://${S3_BUCKET_DATA}/backups/files/ --recursive | grep wordpress-files-${ENVIRONMENT} | sort | tail -n 1)\"
        echo \"======================================\"
      '"
    
    - echo "Backup and verification for ${ENVIRONMENT} environment completed at $(date)!"
  environment:
    name: $ENVIRONMENT-backup
    url: http://$MASTER_IP.nip.io
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: true



monitoring:
  stage: monitoring
  image: $DOCKER_IMAGE
  #include: 'ci/scripts/monitoring/monitoring.yml'
  extends: .monitoring_template
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "dev_chris"
    #- if: $CI_COMMIT_BRANCH == "monitoring"
  needs:
    - job: deploy:kubernetes:dev
      optional: true
    - job: deploy:kubernetes:prod
      optional: true
  environment:
    name: $CI_COMMIT_BRANCH-monitoring
    url: http://$MASTER_IP:30300

verify:prod:
  stage: verify
  image: $DOCKER_IMAGE
  <<: *prod_environment
  needs:
    - deploy:kubernetes:prod
  #include: 'ci/scripts/verify/verify_prod.yml'
  extends: .verify_prod_script
  environment:
    name: $ENVIRONMENT
    url: http://$MASTER_IP.nip.io

verify:dev:
  stage: verify
  image: $DOCKER_IMAGE
  <<: *dev_environment
  needs:
    - deploy:kubernetes:dev
  #include: 'ci/scripts/verify/verify_dev.yml'
  extends:  .verify_dev_script
  environment:
    name: $ENVIRONMENT
    url: http://$MASTER_IP.nip.io

qa:dev:
  stage: qa
  image: $DOCKER_IMAGE
  <<: *dev_environment
  needs:
    - verify:dev
  #include: 'ci/scripts/qa/qa_dev.yml'
  extends: .qa_dev_script
  environment:
    name: $ENVIRONMENT-qa
    url: http://$MASTER_IP.nip.io
  allow_failure: true

qa:prod:
  stage: qa
  image: $DOCKER_IMAGE
  <<: *prod_environment
  needs:
    - verify:prod
  #include: 'ci/scripts/qa/qa_prod.yml'
  extends: .qa_prod_script
  environment:
    name: $ENVIRONMENT-qa
    url: http://$MASTER_IP.nip.io
  allow_failure: true

cleanup:dev:
  stage: cleanup
  image: $DOCKER_IMAGE
  <<: *dev_environment
  #include: 'ci/scripts/cleanup/cleanup_dev.yml'
  extends: .cleanup_dev_script
  environment:
    name: $ENVIRONMENT
    action: stop
  when: manual

cleanup:prod:
  stage: cleanup
  image: $DOCKER_IMAGE
  <<: *prod_environment
  #include: 'ci/scripts/cleanup/cleanup_prod.yml'
  extends: .cleanup_prod_script
  environment:
    name: $ENVIRONMENT
    action: stop
  when: manual

