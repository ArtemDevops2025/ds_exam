# Loading variables
include:
  - local: 'CI/variables.yml'
  - local: 'CI/template/environments.yml'

stages:
  - lint
  - validate
  - plan
  - build
  - deploy
  - monitoring
  - verify
  - qa
  - cleanup

 # Environment-specific variables
# .dev_environment: &dev_environment
#   variables:
#     ENVIRONMENT: "dev"
#     TF_VAR_FILE: "environments/dev/terraform.tfvars"
#     REPLICA_COUNT: "1"
#     MEMORY_REQUEST: "256Mi"
#     MEMORY_LIMIT: "512Mi"
#     CPU_REQUEST: "200m"
#     CPU_LIMIT: "500m"
#     CERT_ISSUER: "staging"
#   rules:
#     - if: $CI_COMMIT_BRANCH == "dev"

# # Production Environment
# .prod_environment: &prod_environment
#   variables:
#     ENVIRONMENT: "prod"
#     TF_VAR_FILE: "environments/prod/terraform.tfvars"
#     REPLICA_COUNT: "2"
#     MEMORY_REQUEST: "512Mi"
#     MEMORY_LIMIT: "1Gi"
#     CPU_REQUEST: "500m"
#     CPU_LIMIT: "1000m"
#     CERT_ISSUER: "prod"
#   rules:
#     - if: $CI_COMMIT_BRANCH == "main"

# build-pipeline-image:
#   stage: prepare
#   image: docker:latest
#   services:
#     - docker:dind
#   before_script:
#     - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
#   script:
#     # Erstelle das SSH-Setup-Skript
#     - |
#       cat > ssh-setup.sh <<'EOF'
#       #!/bin/bash
      
#       if [ -z "$SSH_PRIVATE_KEY" ]; then
#         echo "SSH_PRIVATE_KEY is not set. Please configure this variable in CI/CD settings."
#         exit 1
#       fi

#       if [ -z "$MASTER_IP" ]; then
#         echo "MASTER_IP is not set. Please configure this variable in CI/CD settings."
#         exit 1
#       fi

#       if [ -z "$SSH_KEY_NAME" ]; then
#         SSH_KEY_NAME="ds_exam_key"
#       fi

#       # SSH configuration
#       mkdir -p ~/.ssh
#       echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
#       chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
#       echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config

#       echo "SSH configuration completed successfully"
#       EOF
      
#       chmod +x ssh-setup.sh
    
#     # Erstelle das Dockerfile
#     - |
#       cat > Dockerfile <<EOF
#       FROM alpine:latest

#       # Install all required packages
#       RUN apk add --no-cache bash coreutils curl grep jq openssh-client openssl php php-mysqli yamllint terraform 

#       # Set working directory
#       WORKDIR /app

#       # Set default shell to bash
#       SHELL ["/bin/bash", "-c"]

#       # Create .ssh directory for later use
#       RUN mkdir -p /root/.ssh && chmod 700 /root/.ssh

#       # Create terraform 
#       RUN mkdir -p $TERRAFORM_DIR/

#       # Copy SSH setup script
#       COPY ssh-setup.sh /usr/local/bin/
#       RUN chmod +x /usr/local/bin/ssh-setup.sh

#       # Set environment variables
#       ENV KUBERNETES_DIR="kubernetes" \\
#           REMOTE_DIR="wordpress" \\
#           MONITORING_DIR="monitoring" \\
#           WORDPRESS_PORT="30080" \\
#           DEPLOYMENT_TIMEOUT="300"
#       EOF
    
#     # Bauen und Pushen des Docker-Images
#     - docker build -t $PROJECT_IMAGE .
#     - docker push $PROJECT_IMAGE
#   rules:
#     # - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#     # - if: $CI_COMMIT_BRANCH == "asm"
#     - if: $CI_COMMIT_BRANCH == "main"
#     - if: $CI_COMMIT_BRANCH == "dev"
#     # - if: $CI_COMMIT_BRANCH == "monitoring"

# Make sure all files follow best practices
lint:
  stage: lint
  image: alpine:latest
  script:
    - echo "Linting YAML files for best practices..."
    - apk add --no-cache yamllint
    - |
      cat > .yamllint <<EOF
      extends: default
      rules:
        line-length: disable
        comments:
          min-spaces-from-content: 1
      EOF
    - yamllint -c .yamllint $KUBERNETES_DIR/{templates,environments}/*.yaml* || echo "Linting found issues, but continuing pipeline"
  rules:
    # - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"
    # - if: $CI_COMMIT_BRANCH == "monitoring"
  allow_failure: true
  # needs:
  #   - build-pipeline-image


# Validate Kubernetes manifests templates
validate:kubernetes:
  stage: validate
  image: alpine:latest
  script:
    - echo "Validating Kubernetes manifest templates..."
    - apk add --no-cache grep jq
    - |
      for file in $KUBERNETES_DIR/templates/*.yaml.tpl; do
        echo "Checking $file"
        grep -q "apiVersion:" $file || (echo "Missing apiVersion in $file" && exit 1)
        grep -q "kind:" $file || (echo "Missing kind in $file" && exit 1)
        grep -q "metadata:" $file || (echo "Missing metadata in $file" && exit 1)
        if grep -q "kind: Deployment" $file; then
          grep -q "replicas:" $file || echo "Warning: No replicas specified in Deployment $file"
          grep -q "resources:" $file || echo "Warning: No resource limits/requests in Deployment $file"
        fi
      done
    - echo "All Kubernetes manifest templates are valid!"
  rules:
    # - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"
    # - if: $CI_COMMIT_BRANCH == "monitoring"
  # needs:
  #   - build-pipeline-image


# # Terraform Validation for Both Environments
# validate:terraform:
#   stage: validate
#   image: $PROJECT_IMAGE
#   script:
#     - cd terraform
#     - terraform init
#     - terraform validate
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#     - if: $CI_COMMIT_BRANCH == "main"
#     - if: $CI_COMMIT_BRANCH == "dev"
#     - if: $CI_COMMIT_BRANCH == "monitoring"

# # Terraform Plan - Dev
# plan:dev:
#   stage: plan
#   image: $PROJECT_IMAGE
#   extends: .verify:dev
#   script:
#     - cd terraform
#     - terraform init
#     - terraform workspace select dev 2>/dev/null || terraform workspace new dev
#     - terraform plan -var-file=${TF_VAR_FILE} -out=tfplan
#   artifacts:
#     paths:
#       - terraform/tfplan
#     expire_in: 1 day

# # Terraform Plan - Prod
# plan:prod:
#   stage: plan
#   image: hashicorp/terraform:latest
#   extends: .verify:prod
#   script:
#     - cd terraform
#     - terraform init
#     - terraform workspace select prod 2>/dev/null || terraform workspace new prod
#     - terraform plan -var-file=${TF_VAR_FILE} -out=tfplan
#   artifacts:
#     paths:
#       - terraform/tfplan
#     expire_in: 1 day

build:
  stage: build
  image: alpine:latest
  script:
    - echo "Building WordPress configuration and deployment artifacts..."
    - apk add --no-cache jq openssl bash terraform
    
    # Generate K3s manifests for the appropriate environment
    - chmod +x ./generate-k3s-manifests.sh
    - |
      if [ "$CI_COMMIT_BRANCH" == "dev" ]; then
        ./generate-k3s-manifests.sh dev
      elif [ "$CI_COMMIT_BRANCH" == "main" ]; then
        ./generate-k3s-manifests.sh prod
      else
        echo "Branch not recognized for environment selection, defaulting to dev"
        ./generate-k3s-manifests.sh dev
      fi
    
    # Create QA test scripts
    - mkdir -p $KUBERNETES_DIR/tests
    - |
      cat > $KUBERNETES_DIR/tests/api-tests.sh <<'EOF'
      #!/bin/bash
      # Basic WordPress API tests
      HOST=$1
      
      echo "Testing WordPress REST API..."
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://$HOST:32412/wp-json/)
      if [ $HTTP_CODE -eq 200 ]; then
        echo "✅ WordPress REST API is accessible"
      else
        echo "❌ WordPress REST API is not accessible (HTTP $HTTP_CODE)"
      fi
      
      echo "Testing WordPress posts endpoint..."
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://$HOST:32412/wp-json/wp/v2/posts)
      if [ $HTTP_CODE -eq 200 ]; then
        echo "✅ WordPress posts endpoint is accessible"
      else
        echo "❌ WordPress posts endpoint is not accessible (HTTP $HTTP_CODE)"
      fi
      EOF
      chmod +x $KUBERNETES_DIR/tests/api-tests.sh
    
    - |
      cat > $KUBERNETES_DIR/tests/unit-tests.php <<'EOF'
      <?php
      echo "Running WordPress unit tests...\n";
      
      // Test database connection
      echo "Testing database connection... ";
      $dbhost = getenv('WORDPRESS_DB_HOST') ?: 'wordpress-mysql';
      $dbuser = getenv('WORDPRESS_DB_USER') ?: 'wordpress';
      $dbpass = getenv('WORDPRESS_DB_PASSWORD') ?: 'password';
      $dbname = 'wordpress';
      
      $conn = new mysqli($dbhost, $dbuser, $dbpass, $dbname);
      if ($conn->connect_error) {
        echo "❌ Failed: " . $conn->connect_error . "\n";
      } else {
        echo "✅ Success\n";
        $conn->close();
      }
      
      // Test file permissions
      echo "Testing file permissions... ";
      $wp_content = '/var/www/html/wp-content';
      if (is_writable($wp_content)) {
        echo "✅ wp-content directory is writable\n";
      } else {
        echo "❌ wp-content directory is not writable\n";
      }
      
      // Test PHP extensions
      echo "Testing required PHP extensions...\n";
      $required_extensions = ['mysqli', 'curl', 'gd', 'json'];
      foreach ($required_extensions as $ext) {
        if (extension_loaded($ext)) {
          echo "✅ $ext extension loaded\n";
        } else {
          echo "❌ $ext extension not loaded\n";
        }
      }
      
      echo "Unit tests completed\n";
      EOF
    
    # Generate MySQL service patch file
    - mkdir -p $KUBERNETES_DIR/patches
    - |
      cat > $KUBERNETES_DIR/patches/mysql-service-patch.json <<EOF
      [
        {
          "op": "replace", 
          "path": "/spec/selector", 
          "value": {
            "app": "wordpress-mysql", 
            "tier": "mysql"
          }
        }
      ]
      EOF
    
    # Generate wp-config.php with secure random keys
    - mkdir -p $KUBERNETES_DIR/configmaps
    - |
      cat > $KUBERNETES_DIR/configmaps/wp-config.php <<EOF
      <?php
      define( 'DB_NAME', 'wordpress' );
      define( 'DB_USER', 'wordpress' );
      define( 'DB_PASSWORD', getenv('WORDPRESS_DB_PASSWORD') );
      define( 'DB_HOST', 'wordpress-mysql' );
      define( 'DB_CHARSET', 'utf8' );
      define( 'DB_COLLATE', '' );

      define( 'AUTH_KEY',         '$(openssl rand -hex 16)' );
      define( 'SECURE_AUTH_KEY',  '$(openssl rand -hex 16)' );
      define( 'LOGGED_IN_KEY',    '$(openssl rand -hex 16)' );
      define( 'NONCE_KEY',        '$(openssl rand -hex 16)' );
      define( 'AUTH_SALT',        '$(openssl rand -hex 16)' );
      define( 'SECURE_AUTH_SALT', '$(openssl rand -hex 16)' );
      define( 'LOGGED_IN_SALT',   '$(openssl rand -hex 16)' );
      define( 'NONCE_SALT',       '$(openssl rand -hex 16)' );

      \$table_prefix = 'wp_';

      define( 'WP_DEBUG', true );
      define( 'WP_DEBUG_LOG', true );
      define( 'WP_DEBUG_DISPLAY', false );

      // Dynamic site URL based on request
      define('WP_HOME', 'http://' . \$_SERVER['HTTP_HOST']);
      define('WP_SITEURL', 'http://' . \$_SERVER['HTTP_HOST']);
      
      // S3 configuration (if using)
      if (getenv('S3_BUCKET')) {
        define( 'S3_BUCKET', getenv('S3_BUCKET') );
        define( 'S3_REGION', getenv('S3_REGION') );
        define( 'S3_ACCESS_KEY', getenv('S3_ACCESS_KEY') );
        define( 'S3_SECRET_KEY', getenv('S3_SECRET_KEY') );
      }

      if ( ! defined( 'ABSPATH' ) ) {
        define( 'ABSPATH', __DIR__ . '/' );
      }

      require_once ABSPATH . 'wp-settings.php';
      EOF
    
    # Create ConfigMap YAML for wp-config.php
    - |
      cat > $KUBERNETES_DIR/wp-config-map.yaml <<EOF
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: wordpress-config
        namespace: wordpress-${ENVIRONMENT}
        labels:
          environment: ${ENVIRONMENT}
      data:
        wp-config.php: |
      $(sed 's/^/    /' $KUBERNETES_DIR/configmaps/wp-config.php)
      EOF
    
    - echo "Build artifacts successfully created!"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "monitoring"
  artifacts:
    paths:
      - $KUBERNETES_DIR/
    expire_in: 1 week

# Deploy Terraform infrastructure - Dev
deploy:terraform:dev:
  stage: deploy
  image: hashicorp/terraform:latest
  extends: .verify:dev
  script:
    - apk add --no-cache openssh-client bash
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - cd terraform
    - terraform init
    - terraform workspace select dev 2>/dev/null || terraform workspace new dev
    - terraform apply -var-file=${TF_VAR_FILE} -auto-approve
    - MASTER_IP=$(terraform output -raw k3s_master_ip)
    - echo "MASTER_IP=$MASTER_IP" >> terraform.env
  artifacts:
    reports:
      dotenv: terraform/terraform.env
    paths:
      - terraform/terraform.env
    expire_in: 1 day

# Deploy Terraform infrastructure - Prod
deploy:terraform:prod:
  stage: deploy
  image: hashicorp/terraform:latest
  extends: .verify:prod
  script:
    - apk add --no-cache openssh-client bash
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - cd terraform
    - terraform init
    - terraform workspace select prod 2>/dev/null || terraform workspace new prod
    - terraform apply -var-file=${TF_VAR_FILE} -auto-approve
    - MASTER_IP=$(terraform output -raw k3s_master_ip)
    - echo "MASTER_IP=$MASTER_IP" >> terraform.env
  artifacts:
    reports:
      dotenv: terraform/terraform.env
    paths:
      - terraform/terraform.env
    expire_in: 1 day
  when: manual

# Deploy Kubernetes resources - Dev
deploy:kubernetes:dev:
  stage: deploy
  image: alpine:latest
  extends: .verify:dev
  needs:
    - deploy:terraform:dev
    - build
  before_script:
    - apk add --no-cache openssh-client bash coreutils
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - |
      if [ -z "$MASTER_IP" ]; then
        echo "MASTER_IP is not set. Please configure this variable in CI/CD settings."
        exit 1
      fi
    - echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "Starting deployment to ${ENVIRONMENT} environment at $(date)"
  script:
    # Create directories and transfer files
    - echo "Setting up remote environment..."
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "mkdir -p ~/$REMOTE_DIR-${ENVIRONMENT}"
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/environments/dev/*.yaml ubuntu@$MASTER_IP:~/$REMOTE_DIR-${ENVIRONMENT}/
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/patches/* ubuntu@$MASTER_IP:~/$REMOTE_DIR-${ENVIRONMENT}/ || echo "No patches to copy"
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/wp-config-map.yaml ubuntu@$MASTER_IP:~/$REMOTE_DIR-${ENVIRONMENT}/
    
    # Copy QA test files to remote server
    - echo "Copying QA test files to remote server..."
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "mkdir -p ~/$REMOTE_DIR-${ENVIRONMENT}/tests"
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/tests/* ubuntu@$MASTER_IP:~/$REMOTE_DIR-${ENVIRONMENT}/tests/ || echo "No test files to copy"
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "chmod +x ~/$REMOTE_DIR-${ENVIRONMENT}/tests/*.sh || true"
    
    # Fix potential pre-existing issues
    - echo "Preparing Kubernetes cluster..."
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'sudo kubectl delete -A ValidatingWebhookConfiguration ingress-nginx-admission || true'"
    
    # Core deployments - apply in specific order
    - echo "Deploying core infrastructure..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      echo \"Creating namespace...\" &&
      sudo kubectl apply -f namespace.yaml &&
      echo \"Applying secrets...\" &&
      sudo kubectl apply -f s3-secret.yaml &&
      echo \"Creating persistent volumes...\" &&
      sudo kubectl apply -f wordpress-pvc.yaml &&
      echo \"Applying config map...\" &&
      sudo kubectl apply -f wp-config-map.yaml'"
    
    # Database deployment
    - echo "Deploying database..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      sudo kubectl apply -f mysql-deployment.yaml &&
      echo \"Waiting for MySQL to be ready...\" &&
      timeout $DEPLOYMENT_TIMEOUT bash -c \"until sudo kubectl get pods -n wordpress-${ENVIRONMENT} -l tier=mysql -o jsonpath=\\\"{.items[0].status.phase}\\\" | grep -q Running; do sleep 5; done\" || echo \"MySQL deployment timed out but continuing\"'"
    
    # Fix MySQL service selector - using a patch file approach to avoid quoting issues
    - echo "Fixing MySQL service selector..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "
        echo '[{\"op\": \"replace\", \"path\": \"/spec/selector\", \"value\": {\"app\": \"wordpress-mysql\", \"tier\": \"mysql\"}}]' > patch.json
        sudo kubectl patch svc wordpress-mysql -n wordpress-${ENVIRONMENT} --type=json --patch-file patch.json || true
        rm patch.json
      "
    
    # Application deployment
    - echo "Deploying WordPress application..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      sudo kubectl apply -f wordpress-deployment.yaml &&
      echo \"Waiting for WordPress to be ready...\" &&
      timeout $DEPLOYMENT_TIMEOUT bash -c \"until sudo kubectl get pods -n wordpress-${ENVIRONMENT} -l app=wordpress,environment=${ENVIRONMENT} -o jsonpath=\\\"{.items[0].status.phase}\\\" | grep -q Running; do sleep 5; done\" || echo \"WordPress deployment timed out but continuing\"'"
    
    # Network configuration
    - echo "Configuring network resources..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      echo \"Creating services...\" &&
      sudo kubectl apply -f wordpress-service.yaml &&
      sudo kubectl apply -f wordpress-loadbalancer.yaml &&
      echo \"Waiting for services to be assigned IPs...\" &&
      timeout 60 bash -c \"until sudo kubectl get svc wordpress-lb -n wordpress-${ENVIRONMENT} -o jsonpath=\\\"{.spec.clusterIP}\\\" | grep -q -v none; do sleep 2; done\" || echo \"Service IP assignment timed out but continuing\"'"
    
    # Ingress configuration
    - echo "Configuring ingress..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      echo \"Applying ingress...\" &&
      sudo kubectl apply -f ingress.yaml || echo \"Ingress creation failed but continuing deployment\"'"
    
    - echo "WordPress deployment to ${ENVIRONMENT} environment completed successfully at $(date)!"
  environment:
    name: $ENVIRONMENT
    url: http://$MASTER_IP.nip.io
  artifacts:
    paths:
      - $KUBERNETES_DIR/
    expire_in: 1 week

# Deploy Kubernetes resources - Prod
deploy:kubernetes:prod:
  stage: deploy
  image: alpine:latest
  extends: .verify:prod
  needs:
    - deploy:terraform:prod
    - build
  before_script:
    - apk add --no-cache openssh-client bash coreutils
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - |
      if [ -z "$MASTER_IP" ]; then
        echo "MASTER_IP is not set. Please configure this variable in CI/CD settings."
        exit 1
      fi
    - echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "Starting deployment to ${ENVIRONMENT} environment at $(date)"
  script:
    # Same script as dev environment, but with different environment variables
    - echo "Setting up remote environment..."
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "mkdir -p ~/$REMOTE_DIR-${ENVIRONMENT}"
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/environments/prod/*.yaml ubuntu@$MASTER_IP:~/$REMOTE_DIR-${ENVIRONMENT}/
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/patches/* ubuntu@$MASTER_IP:~/$REMOTE_DIR-${ENVIRONMENT}/ || echo "No patches to copy"
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/wp-config-map.yaml ubuntu@$MASTER_IP:~/$REMOTE_DIR-${ENVIRONMENT}/
    
    # Copy QA test files to remote server
    - echo "Copying QA test files to remote server..."
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "mkdir -p ~/$REMOTE_DIR-${ENVIRONMENT}/tests"
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/tests/* ubuntu@$MASTER_IP:~/$REMOTE_DIR-${ENVIRONMENT}/tests/ || echo "No test files to copy"
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "chmod +x ~/$REMOTE_DIR-${ENVIRONMENT}/tests/*.sh || true"
    
    # Fix potential pre-existing issues
    - echo "Preparing Kubernetes cluster..."
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'sudo kubectl delete -A ValidatingWebhookConfiguration ingress-nginx-admission || true'"
    
    # Core deployments - apply in specific order
    - echo "Deploying core infrastructure..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      echo \"Creating namespace...\" &&
      sudo kubectl apply -f namespace.yaml &&
      echo \"Applying secrets...\" &&
      sudo kubectl apply -f s3-secret.yaml &&
      echo \"Creating persistent volumes...\" &&
      sudo kubectl apply -f wordpress-pvc.yaml &&
      echo \"Applying config map...\" &&
      sudo kubectl apply -f wp-config-map.yaml'"
    
    # Database deployment
    - echo "Deploying database..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      sudo kubectl apply -f mysql-deployment.yaml &&
      echo \"Waiting for MySQL to be ready...\" &&
      timeout $DEPLOYMENT_TIMEOUT bash -c \"until sudo kubectl get pods -n wordpress-${ENVIRONMENT} -l tier=mysql -o jsonpath=\\\"{.items[0].status.phase}\\\" | grep -q Running; do sleep 5; done\" || echo \"MySQL deployment timed out but continuing\"'"
    
    # Fix MySQL service selector - using a patch file approach to avoid quoting issues
    - echo "Fixing MySQL service selector..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "
        echo '[{\"op\": \"replace\", \"path\": \"/spec/selector\", \"value\": {\"app\": \"wordpress-mysql\", \"tier\": \"mysql\"}}]' > patch.json
        sudo kubectl patch svc wordpress-mysql -n wordpress-${ENVIRONMENT} --type=json --patch-file patch.json || true
        rm patch.json
      "
    
    # Application deployment
    - echo "Deploying WordPress application..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      sudo kubectl apply -f wordpress-deployment.yaml &&
      echo \"Waiting for WordPress to be ready...\" &&
      timeout $DEPLOYMENT_TIMEOUT bash -c \"until sudo kubectl get pods -n wordpress-${ENVIRONMENT} -l app=wordpress,environment=${ENVIRONMENT} -o jsonpath=\\\"{.items[0].status.phase}\\\" | grep -q Running; do sleep 5; done\" || echo \"WordPress deployment timed out but continuing\"'"
    
    # Network configuration
    - echo "Configuring network resources..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      echo \"Creating services...\" &&
      sudo kubectl apply -f wordpress-service.yaml &&
      sudo kubectl apply -f wordpress-loadbalancer.yaml &&
      echo \"Waiting for services to be assigned IPs...\" &&
      timeout 60 bash -c \"until sudo kubectl get svc wordpress-lb -n wordpress-${ENVIRONMENT} -o jsonpath=\\\"{.spec.clusterIP}\\\" | grep -q -v none; do sleep 2; done\" || echo \"Service IP assignment timed out but continuing\"'"
    
    # Ingress configuration
    - echo "Configuring ingress..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} &&
      echo \"Applying ingress...\" &&
      sudo kubectl apply -f ingress.yaml || echo \"Ingress creation failed but continuing deployment\"'"
    
    - echo "WordPress deployment to ${ENVIRONMENT} environment completed successfully at $(date)!"
  environment:
    name: $ENVIRONMENT
    url: http://$MASTER_IP.nip.io
  artifacts:
    paths:
      - $KUBERNETES_DIR/
    expire_in: 1 week

# Verify deployment for production
verify:prod:
  extends: .verfiy_template
  extends: .verify:prod
  needs:
    - deploy:kubernetes:prod

monitoring:
  stage: monitoring
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client bash
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
  script:
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "mkdir -p ~/$MONITORING_DIR/prometheus ~/$MONITORING_DIR/grafana"
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/monitoring/monitoring-namespace.yaml ubuntu@$MASTER_IP:~/$MONITORING_DIR/
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/monitoring/prometheus/*.yaml ubuntu@$MASTER_IP:~/$MONITORING_DIR/prometheus/
    - scp -i ~/.ssh/$SSH_KEY_NAME.pem $KUBERNETES_DIR/monitoring/grafana/*.yaml ubuntu@$MASTER_IP:~/$MONITORING_DIR/grafana/
    - >
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "
        sudo kubectl apply -f ~/$MONITORING_DIR/monitoring-namespace.yaml &&
        sudo kubectl apply -f ~/$MONITORING_DIR/prometheus/ &&
        sudo kubectl apply -f ~/$MONITORING_DIR/grafana/ &&
        timeout 120 bash -c 'until sudo kubectl get pods -n monitoring -l app=prometheus -o jsonpath=\"{.items[0].status.phase}\" | grep -q Running; do sleep 5; done' ||
        echo 'Prometheus timed out' &&
        timeout 120 bash -c 'until sudo kubectl get pods -n monitoring -l app=grafana -o jsonpath=\"{.items[0].status.phase}\" | grep -q Running; do sleep 5; done' ||
        echo 'Grafana timed out'
      "
    - ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "sudo kubectl get all -n monitoring"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "monitoring"
    - if: $CI_COMMIT_BRANCH == "dev_chris"
  needs:
    - job: deploy:kubernetes:dev
      optional: true
    - job: deploy:kubernetes:prod
      optional: true
  environment:
    name: $CI_COMMIT_BRANCH-monitoring
    url: http://$MASTER_IP:30300

# Verify deployment is working correctly for dev
verify:dev:
  extends: .verify:dev
  needs:
    - deploy:kubernetes:dev


# Quality Assurance testing - Dev

qa:dev:
  stage: qa
  image: alpine:latest
  extends: .verify:dev
  needs:
    - verify:dev
  before_script:
    - apk add --no-cache openssh-client curl bash php php-mysqli
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "Starting QA tests for ${ENVIRONMENT} environment at $(date)"
  script:
    # Run API tests
    - echo "Running WordPress API tests..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} && 
      ./tests/api-tests.sh $MASTER_IP'"
    
    # Run unit tests inside WordPress pod
    - echo "Running WordPress unit tests..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
      WP_POD=\$(sudo kubectl get pod -l app=wordpress,environment=${ENVIRONMENT} -n wordpress-${ENVIRONMENT} -o jsonpath=\"{.items[0].metadata.name}\")
      echo "Using WordPress pod: \$WP_POD"
      sudo kubectl cp ~/$REMOTE_DIR-${ENVIRONMENT}/tests/unit-tests.php wordpress-${ENVIRONMENT}/\$WP_POD:/tmp/unit-tests.php
      sudo kubectl exec \$WP_POD -n wordpress-${ENVIRONMENT} -- php /tmp/unit-tests.php
      '"
    
    # Security scan
    - echo "Running security scan..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
      echo \"Checking for exposed sensitive endpoints...\"
      ADMIN_EXPOSED=\$(curl -s -o /dev/null -w \"%{http_code}\" http://$MASTER_IP.nip.io/wp-admin/install.php)
      if [ \"\$ADMIN_EXPOSED\" == \"200\" ] || [ \"\$ADMIN_EXPOSED\" == \"302\" ]; then
        echo \"⚠️ Warning: WordPress installation page might be accessible\"
      else
        echo \"✅ WordPress installation page properly secured\"
      fi
      
      echo \"Checking WordPress version disclosure...\"
      VERSION_CHECK=\$(curl -s http://$MASTER_IP.nip.io | grep -c \"meta name=\\\"generator\\\"\" || true)
      if [ \"\$VERSION_CHECK\" -gt 0 ]; then
        echo \"⚠️ Warning: WordPress version might be exposed in HTML\"
      else
        echo \"✅ WordPress version properly hidden\"
      fi
      '"
    
    # Performance test
    - echo "Running basic performance test..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
      echo \"Testing response time...\"
      RESPONSE_TIME=\$(curl -s -w \"Time: %{time_total}s\n\" -o /dev/null http://$MASTER_IP.nip.io)
      echo \"\$RESPONSE_TIME\"
      
      echo \"Testing concurrent connections...\"
      for i in {1..5}; do
        curl -s http://$MASTER_IP.nip.io > /dev/null &
      done
      wait
      echo \"Concurrent connection test completed\"
      '"
    
    - echo "QA testing for ${ENVIRONMENT} environment completed at $(date)!"
  environment:
    name: $ENVIRONMENT-qa
    url: http://$MASTER_IP.nip.io
  allow_failure: true

# Quality Assurance testing - Prod
qa:prod:
  stage: qa
  image: alpine:latest
  extends: .verify:prod
  needs:
    - verify:prod
  before_script:
    - apk add --no-cache openssh-client curl bash php php-mysqli
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "Starting QA tests for ${ENVIRONMENT} environment at $(date)"
  script:
    # Run API tests
    - echo "Running WordPress API tests..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c 'cd ~/$REMOTE_DIR-${ENVIRONMENT} && 
      ./tests/api-tests.sh $MASTER_IP'"
    
    # Run unit tests inside WordPress pod
    - echo "Running WordPress unit tests..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
      WP_POD=\$(sudo kubectl get pod -l app=wordpress,environment=${ENVIRONMENT} -n wordpress-${ENVIRONMENT} -o jsonpath=\"{.items[0].metadata.name}\")
      echo "Using WordPress pod: \$WP_POD"
      sudo kubectl cp ~/$REMOTE_DIR-${ENVIRONMENT}/tests/unit-tests.php wordpress-${ENVIRONMENT}/\$WP_POD:/tmp/unit-tests.php
      sudo kubectl exec \$WP_POD -n wordpress-${ENVIRONMENT} -- php /tmp/unit-tests.php
      '"
    
    # Security scan
    - echo "Running security scan..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
      echo \"Checking for exposed sensitive endpoints...\"
      ADMIN_EXPOSED=\$(curl -s -o /dev/null -w \"%{http_code}\" http://$MASTER_IP.nip.io/wp-admin/install.php)
      if [ \"\$ADMIN_EXPOSED\" == \"200\" ] || [ \"\$ADMIN_EXPOSED\" == \"302\" ]; then
        echo \"⚠️ Warning: WordPress installation page might be accessible\"
      else
        echo \"✅ WordPress installation page properly secured\"
      fi
      
      echo \"Checking WordPress version disclosure...\"
      VERSION_CHECK=\$(curl -s http://$MASTER_IP.nip.io | grep -c \"meta name=\\\"generator\\\"\" || true)
      if [ \"\$VERSION_CHECK\" -gt 0 ]; then
        echo \"⚠️ Warning: WordPress version might be exposed in HTML\"
      else
        echo \"✅ WordPress version properly hidden\"
      fi
      '"
    
    # Performance test with higher standards for production
    - echo "Running comprehensive performance test..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
      echo \"Testing response time...\"
      RESPONSE_TIME=\$(curl -s -w \"Time: %{time_total}s\n\" -o /dev/null http://$MASTER_IP.nip.io)
      echo \"\$RESPONSE_TIME\"
      
      echo \"Testing concurrent connections (higher load for production)...\"
      for i in {1..10}; do
        curl -s http://$MASTER_IP.nip.io > /dev/null &
      done
      wait
      echo \"Concurrent connection test completed\"
      
      # Test load balancing between replicas
      echo \"Testing load balancing between replicas...\"
      for i in {1..5}; do
        SERVER_HEADER=\$(curl -s -I http://$MASTER_IP.nip.io | grep -i \"X-Served-By\" || echo \"No server header\")
        echo \"Request \$i: \$SERVER_HEADER\"
        sleep 1
      done
      '"
    
    - echo "QA testing for ${ENVIRONMENT} environment completed at $(date)!"
  environment:
    name: $ENVIRONMENT-qa
    url: http://$MASTER_IP.nip.io
  allow_failure: true

# Cleanup dev environment
cleanup:dev:
  stage: cleanup
  image: alpine:latest
  extends: .verify:dev
  before_script:
    - apk add --no-cache openssh-client bash
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
  script:
    - echo "Starting cleanup process for ${ENVIRONMENT} environment at $(date)..."
    
    - echo "Removing all WordPress resources for ${ENVIRONMENT} environment..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
        echo \"Removing ingress resources...\"
        sudo kubectl delete ingress -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing service resources...\"
        sudo kubectl delete svc -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing deployment resources...\"
        sudo kubectl delete deployment -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing statefulset resources...\"
        sudo kubectl delete statefulset -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing configmap resources...\"
        sudo kubectl delete configmap -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing secret resources...\"
        sudo kubectl delete secret -n wordpress-${ENVIRONMENT} --all
        
        echo \"Waiting for pods to terminate...\"
        timeout 60 bash -c \"until [ \\\$(sudo kubectl get pods -n wordpress-${ENVIRONMENT} --no-headers | wc -l) -eq 0 ]; do sleep 5; done\" || echo \"Pod termination timed out\"
        
        echo \"Removing PVC resources...\"
        sudo kubectl delete pvc -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing namespace...\"
        sudo kubectl delete namespace wordpress-${ENVIRONMENT}
        
        echo \"Removing local files...\"
        rm -rf ~/$REMOTE_DIR-${ENVIRONMENT}
      '"
    
    - echo "Cleanup of ${ENVIRONMENT} environment completed at $(date)!"
  environment:
    name: $ENVIRONMENT
    action: stop
  when: manual

# Cleanup prod environment
cleanup:prod:
  stage: cleanup
  image: alpine:latest
  extends: .verify:prod
  before_script:
    - apk add --no-cache openssh-client bash
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$SSH_KEY_NAME.pem
    - chmod 600 ~/.ssh/$SSH_KEY_NAME.pem
    - echo -e "Host $MASTER_IP\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
  script:
    - echo "Starting cleanup process for ${ENVIRONMENT} environment at $(date)..."
    
    - echo "Removing all WordPress resources for ${ENVIRONMENT} environment..."
    - |
      ssh -i ~/.ssh/$SSH_KEY_NAME.pem ubuntu@$MASTER_IP "bash -l -c '
        echo \"Removing ingress resources...\"
        sudo kubectl delete ingress -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing service resources...\"
        sudo kubectl delete svc -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing deployment resources...\"
        sudo kubectl delete deployment -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing statefulset resources...\"
        sudo kubectl delete statefulset -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing configmap resources...\"
        sudo kubectl delete configmap -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing secret resources...\"
        sudo kubectl delete secret -n wordpress-${ENVIRONMENT} --all
        
        echo \"Waiting for pods to terminate...\"
        timeout 60 bash -c \"until [ \\\$(sudo kubectl get pods -n wordpress-${ENVIRONMENT} --no-headers | wc -l) -eq 0 ]; do sleep 5; done\" || echo \"Pod termination timed out\"
        
        echo \"Removing PVC resources...\"
        sudo kubectl delete pvc -n wordpress-${ENVIRONMENT} --all
        
        echo \"Removing namespace...\"
        sudo kubectl delete namespace wordpress-${ENVIRONMENT}
        
        echo \"Removing local files...\"
        rm -rf ~/$REMOTE_DIR-${ENVIRONMENT}
      '"
    
    - echo "Cleanup of ${ENVIRONMENT} environment completed at $(date)!"
  environment:
    name: $ENVIRONMENT
    action: stop
  when: manual